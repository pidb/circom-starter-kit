const { execSync } = require("child_process");
const snarkjs = require("snarkjs")
const toml = require("toml");
const fs = require("fs");
const which = require("which");
const path = require("path");
const camelcase = require("camelcase")

const COMMAND = "circom"
const CIRCOM_FILE = "circuit.circom"

class CompileConfig {
    constructor(inputPath, outputPath, ptau, circurts) {
        this.inputPath = inputPath
        this.outputPath = outputPath
        this.circurts = circurts
        this.ptau = ptau
    }
}

class Circuit {
    constructor(name, protocol, circut, input, zkey) {
        this.name = name
        this.protocol = protocol
        this.circut = circut
        this.input = input
        this.zkey = zkey
    }
}

const main = async () => {
    try {
        const _ = await which("circom")
    } catch (error) {
       throw new Error("Circom not found in path")
    }

    const compileConfig = {
        inputPath: "./circuits",
        outputPath: "./client",
        ptau: "powersOfTau28_hez_final_15.ptau",
    }

    const circuitConfig = toml.parse(fs.readFileSync(`${compileConfig.inputPath}/circuit.config.toml`, "utf-8"));
    if (!circuitConfig) {
        throw new Error("Circuit config not found")
    }

    const circuitNames = fs.readdirSync(compileConfig.inputPath, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);
    
    let circuits = []
    circuitNames.forEach((name, index) => {
        let protocol = circuitConfig.protocol[name] || circuitConfig.protocol.default
        let compiler = circuitConfig.compiler[name] || circuitConfig.compiler.default
        circuits[index] = {
            name: name,
            version: compiler,
            protocol: protocol,
            circuit: `${name}/${CIRCOM_FILE}`,
            input: `${name}/input.json`,
            zkey: `${name}.zkey`,
        }
    })

    const snarkjsRoot = path.dirname(require.resolve("snarkjs"));
    const templateDir = fs.existsSync(path.join(snarkjsRoot, "templates")) ? "templates" : "../templates";
    const verifierGroth16TemplatePath = path.join(snarkjsRoot, templateDir, "verifier_groth16.sol.ejs");
    const verifierPlonkTemplatePath = path.join(snarkjsRoot, templateDir, "verifier_plonk.sol.ejs");
    const groth16Template = fs.readFileSync(verifierGroth16TemplatePath, "utf-8");
    const plonkTemplate = fs.readFileSync(verifierPlonkTemplatePath, "utf-8");

    for (const circuit of circuits) {
        const outdir = `${compileConfig.outputPath}/${circuit.name}`;
        if (!fs.existsSync(outdir)) {
          fs.mkdirSync(outdir, { recursive: true });
        }
      
        const compileCommand = `${COMMAND} ${compileConfig.inputPath}/${circuit.name}/${CIRCOM_FILE} --r1cs --wasm --sym -o ${outdir}`;
        try {
          execSync(compileCommand, (error, stdout, stderr) => {
            if (error) {
              throw error;
            }
          });
        } catch (error) {
          throw new Error(`Compiling circuit ${circuit.name} error: ${error}`);
        }
      
        const r1cs = `${outdir}/circuit.r1cs`;
        const zkey = `${outdir}/${circuit.zkey}`
        console.log(`Creating zkey ${outdir}/${circuit.zkey} for ${circuit.name}`);
        await snarkjs.zKey.newZKey(r1cs, `${compileConfig.inputPath}/${compileConfig.ptau}`, zkey);
        
        console.log(`Exporting solidity verifier for ${circuit.name}`);
        snarkjs.zKey.exportSolidityVerifier(zkey, {
            groth16: `${outdir}/verifier.sol`
        });

        const warning = "// THIS FILE IS GENERATED BY HARDHAT-CIRCOM. DO NOT EDIT THIS FILE.\n";
        const circuitSol = await snarkjs.zKey.exportSolidityVerifier(zkey, {
            groth16: groth16Template,
            plonk: plonkTemplate,
        });
        const finalSol = warning + circuitSol;

        const name = camelcase(circuit.name, {
          pascalCase: true,
          preserveConsecutiveUppercase: true,
          locale: false,
        });
    
        const verifier = path.join("./contracts", `${name}Verifier.sol`);
        console.log(verifier)
         fs.mkdirSync(path.dirname(verifier), { recursive: true });
         fs.writeFileSync(verifier, finalSol);
    } 
};

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
